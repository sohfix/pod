#!/usr/bin/env python3
import argparse
import os
import subprocess
import sys
import configparser
import shlex
import platform
import json
from datetime import datetime

CONFIG_PATH = "config.ini"

def load_config_output_dir():
    config = configparser.ConfigParser()
    if os.path.exists(CONFIG_PATH):
        config.read(CONFIG_PATH)
        return config.get("settings", "output_dir", fallback="./downloads")
    return "./downloads"

def sanitize_filename(name):
    return "".join(c for c in name if c.isalnum() or c in " .-_").strip()

def open_file(filepath):
    system = platform.system()
    try:
        if system == "Darwin":   # macOS
            subprocess.run(["open", filepath])
        elif system == "Windows":
            os.startfile(filepath)  # type: ignore
        else:  # Linux and others
            subprocess.run(["xdg-open", filepath])
    except Exception as e:
        print(f"[!] Failed to open file: {e}")

def run_yt_dlp(url, output_dir, filename=None, video=False, playlist=False, json_log=False, auto_open=False):
    os.makedirs(output_dir, exist_ok=True)

    ext = "mp4" if video else "mp3"
    sanitized = sanitize_filename(filename) if filename else "%(title)s"
    output_template = os.path.join(output_dir, f"{sanitized}.%(ext)s")

    # Base yt-dlp command
    command = [
        "yt-dlp",
        url,
        "-o", output_template,
    ]

    # Format selection
    if video:
        command += ["-f", "bv*+ba/b"]
    else:
        command += ["-f", "bestaudio", "--extract-audio", "--audio-format", "mp3"]

    # Playlist handling
    if not playlist:
        command += ["--no-playlist"]

    # JSON logging
    if json_log:
        command += ["--print-json"]

    try:
        print(f"[+] Running: {' '.join(shlex.quote(arg) for arg in command)}")
        if json_log:
            # Capture yt-dlp JSON output
            result = subprocess.run(command, capture_output=True, text=True, check=True)
            lines = result.stdout.strip().splitlines()
            metadata = [json.loads(line) for line in lines if line.strip()]
            
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            log_path = os.path.join(output_dir, f"rip_log_{timestamp}.json")
            with open(log_path, "w", encoding="utf-8") as f:
                json.dump(metadata, f, indent=2)
            print(f"[✓] Metadata logged to {log_path}")
        else:
            subprocess.run(command, check=True)

        print("[✓] Download complete")

        # Auto-open only for single downloads
        if auto_open and not playlist:
            # Guess downloaded file path
            if filename:
                final_file = os.path.join(output_dir, f"{sanitize_filename(filename)}.{ext}")
                if os.path.exists(final_file):
                    open_file(final_file)
            else:
                print("[i] Auto-open skipped (no explicit filename given).")

    except subprocess.CalledProcessError as e:
        print(f"[!] yt-dlp failed: {e}")
        sys.exit(1)

def main():
    parser = argparse.ArgumentParser(description="YouTube downloader (audio/video) using yt-dlp")
    parser.add_argument("--url", required=True, help="YouTube video or playlist URL")
    parser.add_argument("--video", action="store_true", help="Download video (default: audio only)")
    parser.add_argument("--playlist", action="store_true", help="Download entire playlist")
    parser.add_argument("--json", action="store_true", help="Log metadata to JSON")
    parser.add_argument("--open", action="store_true", help="Open file after download (single only)")
    parser.add_argument("-o", "--output", help="Output directory")
    parser.add_argument("-n", "--name", help="Custom filename (without extension)")

    args = parser.parse_args()
    output_dir = args.output if args.output else load_config_output_dir()

    run_yt_dlp(
        args.url,
        output_dir,
        filename=args.name,
        video=args.video,
        playlist=args.playlist,
        json_log=args.json,
        auto_open=args.open
    )

if __name__ == "__main__":
    main()