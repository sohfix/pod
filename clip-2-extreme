#!/usr/bin/env python3
import argparse, csv, json, os, re, subprocess, sys, tempfile
from pathlib import Path
from typing import Optional, Tuple, List

APP_NAME = "podmix"
CONFIG_DIR = Path(os.environ.get("XDG_CONFIG_HOME", Path.home() / ".config")) / APP_NAME
CONFIG_PATH = CONFIG_DIR / "config.json"

# ---------------- Utilities ----------------

TIME_PATTERNS = [
    re.compile(r"^(?P<m>\d+):(?P<s>[0-5]?\d)$"),                 # M:SS
    re.compile(r"^(?P<h>\d+):(?P<m>[0-5]?\d):(?P<s>[0-5]?\d)$"), # H:MM:SS
    re.compile(r"^(?P<s>\d+)$"),                                 # seconds (int)
]

def parse_time(ts: str) -> float:
    s = ts.strip()
    for pat in TIME_PATTERNS:
        m = pat.match(s)
        if m:
            h = int(m.groupdict().get("h") or 0)
            m_ = int(m.groupdict().get("m") or 0)
            s_ = int(m.groupdict().get("s") or 0)
            return h * 3600 + m_ * 60 + s_
    raise ValueError(f"Invalid time format: {ts!r}")

def load_config() -> dict:
    if CONFIG_PATH.exists():
        try: return json.loads(CONFIG_PATH.read_text())
        except Exception: pass
    return {}

def save_config(cfg: dict) -> None:
    CONFIG_DIR.mkdir(parents=True, exist_ok=True)
    CONFIG_PATH.write_text(json.dumps(cfg, indent=2))

def ensure_outdir(path: Optional[str], cfg: dict) -> Path:
    outdir = Path(path) if path else Path(cfg.get("output_default", "."))
    outdir.mkdir(parents=True, exist_ok=True)
    return outdir

def sanitize_filename(name: str) -> str:
    return re.sub(r'[\\/:*?"<>|]+', "_", name).strip()

def choose_encode_args(cbr: Optional[str], mono: bool) -> List[str]:
    """
    Return ffmpeg audio encode args for final renders (or parts when re-encoding).
    Default: VBR -q:a 2. If cbr is like '192k', use -b:a 192k.
    """
    args = ["-acodec", "libmp3lame"]
    if cbr:
        args += ["-b:a", str(cbr)]
    else:
        args += ["-q:a", "2"]  # good VBR for podcasts
    if mono:
        args += ["-ac", "1"]
    return args

# ---------------- Cutting & helpers ----------------

def run_ffmpeg_cut(
    input_mp3: Path,
    start_s: float,
    end_s: float,
    out_path: Path,
    title: Optional[str] = None,
    comment: Optional[str] = None,
    copy: bool = False,
    edge_fade: float = 0.0,
    cbr: Optional[str] = None,
) -> None:
    """
    Cut a segment. If edge_fade>0, we apply tiny afade in/out (requires re-encode).
    If copy=True and edge_fade>0, we ignore edge_fade to preserve copy (warn via print).
    """
    if end_s <= start_s:
        raise ValueError("end must be greater than start")
    duration = end_s - start_s

    meta = []
    if title:   meta += ["-metadata", f"title={title}"]
    if comment: meta += ["-metadata", f"comment={comment}"]

    # Build base command
    cmd = [
        "ffmpeg", "-hide_banner", "-loglevel", "error",
        "-ss", f"{start_s:.3f}", "-t", f"{duration:.3f}",
        "-i", str(input_mp3),
    ]

    # Decide codec/filter
    if copy and edge_fade <= 0:
        codec_args = ["-c", "copy"]
        filter_args: List[str] = []
    else:
        # re-encode path
        codec_args = choose_encode_args(cbr=cbr, mono=False)
        filter_chain = []
        if edge_fade > 0:
            # Fade in from 0, fade out starting at duration-edge_fade
            st_out = max(0.0, duration - edge_fade)
            filter_chain.append(f"afade=t=in:st=0:d={edge_fade}")
            filter_chain.append(f"afade=t=out:st={st_out:.3f}:d={edge_fade}")
        filter_args = ["-af", ",".join(filter_chain)] if filter_chain else []

        if copy and edge_fade > 0:
            print(f"note: --copy ignored for {out_path.name} because --edge-fade requires re-encode")

    cmd += filter_args + codec_args + meta + [str(out_path)]
    if subprocess.run(cmd).returncode != 0:
        raise RuntimeError(f"ffmpeg failed for {out_path.name}")

def sniff_has_header(row: List[str]) -> bool:
    joined = ",".join(c.strip().lower() for c in row)
    return "start" in joined and "end" in joined

def parse_batch_file(path: Path) -> Tuple[str, List[dict]]:
    """
    CSV format:
      #default, Your default description (optional; first such line wins)
      start,end,name,description
      3:55,4:55,hot_take,#default
      2:35,3:33,funny_bit,Hosts crack up
      420,505,,
    """
    default_desc = ""
    clips: List[dict] = []
    with path.open(newline="", encoding="utf-8") as f:
        reader = csv.reader(f)
        first_row = None
        for raw in reader:
            if not raw or (len(raw) == 1 and not raw[0].strip()):
                continue
            if raw[0].strip().startswith("#default"):
                if len(raw) >= 2:
                    default_desc = ",".join(raw[1:]).strip()
                continue
            if raw[0].strip().startswith("#"):
                continue
            if first_row is None:
                first_row = raw
                if sniff_has_header(first_row):
                    first_row = None
                    continue
            row = raw if first_row is None else first_row
            first_row = None
            row = (row + ["", "", "", ""])[:4]
            start, end, name, desc = [c.strip() for c in row]
            if not start or not end:
                raise ValueError(f"Batch row missing start/end: {row}")
            start_s = parse_time(start); end_s = parse_time(end)
            nm = sanitize_filename(name) if name else ""
            description = default_desc if (desc == "#default" or desc == "") else desc
            clips.append({"start_s": start_s, "end_s": end_s, "name": nm, "description": description})
    return default_desc, clips

def derive_outfile(base_dir: Path, base_name: Optional[str], idx: int) -> Path:
    stem = sanitize_filename(base_name) if base_name else f"clip_{idx:02d}"
    return base_dir / f"{stem}.mp3"

# ---------------- Concat helpers ----------------

def make_silence_mp3(path: Path, duration: float, cbr: Optional[str], mono: bool) -> None:
    """
    Create a silent MP3 of given duration (seconds) using anullsrc.
    """
    if duration <= 0:
        return
    cmd = [
        "ffmpeg", "-hide_banner", "-loglevel", "error",
        "-f", "lavfi", "-t", f"{duration:.3f}",
        "-i", "anullsrc=channel_layout=stereo:sample_rate=44100",
        *choose_encode_args(cbr=cbr, mono=mono),
        str(path)
    ]
    if subprocess.run(cmd).returncode != 0:
        raise RuntimeError("failed to generate silence clip")

def build_xfade_filter(n_parts: int, xfade: float, shape: str,
                       add_limiter: bool, loudnorm_i: Optional[float]) -> Tuple[str, str]:
    """
    Returns (filter_complex, final_label). Chains acrossfade over N inputs.
    After last fade, optionally applies limiter and loudnorm on the labeled stream.
    """
    if n_parts == 1:
        # No acrossfade needed; we'll apply post-filters separately outside if desired.
        return "", "0:a"

    shape = shape.lower()
    if shape not in {"tri", "exp", "log", "qsin"}:
        shape = "tri"

    filters = []
    prev = "0:a"
    for i in range(1, n_parts):
        cur = f"{i}:a"
        out = f"af{i}"
        filters.append(f"[{prev}][{cur}]acrossfade=d={xfade}:c1={shape}:c2={shape}[{out}]")
        prev = out

    final_label = prev

    # Post-filters: limiter then loudness, in that order
    if add_limiter:
        filters.append(f"[{final_label}]alimiter=limit=0.90[lim]")
        final_label = "lim"

    if loudnorm_i is not None:
        # Simple one-pass loudnorm; TP â‰ˆ -1.5 dB, typical LRA
        filters.append(f"[{final_label}]loudnorm=I={loudnorm_i}:TP=-1.5:LRA=11[ln]")
        final_label = "ln"

    return ";".join(filters), final_label

def ffmpeg_concat_list(list_file: Path, out_path: Path, copy: bool,
                       title: Optional[str], comment: Optional[str],
                       filter_a: Optional[str], cbr: Optional[str], mono: bool) -> None:
    """
    Concat demuxer path. If filter_a is provided or mono/cbr needs encoding,
    we re-encode with libmp3lame; otherwise we stream copy.
    """
    meta = []
    if title:   meta += ["-metadata", f"title={title}"]
    if comment: meta += ["-metadata", f"comment={comment}"]

    cmd = ["ffmpeg", "-hide_banner", "-loglevel", "error",
           "-f", "concat", "-safe", "0", "-i", str(list_file)]

    must_encode = bool(filter_a) or mono or not copy or bool(cbr)
    if must_encode:
        if filter_a:
            cmd += ["-filter:a", filter_a]
        cmd += choose_encode_args(cbr=cbr, mono=mono)
    else:
        cmd += ["-c", "copy"]

    cmd += meta + [str(out_path)]
    if subprocess.run(cmd).returncode != 0:
        raise RuntimeError(f"ffmpeg concat failed for {out_path.name}")

def ffmpeg_concat_xfade(parts: List[Path], out_path: Path, xfade: float, shape: str,
                        title: Optional[str], comment: Optional[str],
                        cbr: Optional[str], mono: bool,
                        add_limiter: bool, loudnorm_i: Optional[float]) -> None:
    """
    Multi-input, filter_complex acrossfade with optional limiter/loudnorm.
    Always re-encodes the final output.
    """
    # Build command
    cmd = ["ffmpeg", "-hide_banner", "-loglevel", "error"]
    for p in parts:
        cmd += ["-i", str(p)]

    filter_complex, final_label = build_xfade_filter(
        n_parts=len(parts),
        xfade=xfade,
        shape=shape,
        add_limiter=add_limiter,
        loudnorm_i=loudnorm_i
    )

    # If only one input, we may not have a filter_complex; handle mapping accordingly
    map_args = []
    if filter_complex:
        cmd += ["-filter_complex", filter_complex]
        map_args = ["-map", f"[{final_label}]"]
    else:
        map_args = ["-map", "0:a"]

    cmd += map_args + choose_encode_args(cbr=cbr, mono=mono)

    if title:   cmd += ["-metadata", f"title={title}"]
    if comment: cmd += ["-metadata", f"comment={comment}"]

    cmd += [str(out_path)]
    if subprocess.run(cmd).returncode != 0:
        raise RuntimeError(f"ffmpeg xfade failed for {out_path.name}")

# ---------------- Commands ----------------

def cmd_set(args):
    cfg = load_config()
    if args.output_default:
        cfg["output_default"] = str(Path(args.output_default).expanduser())
        save_config(cfg)
        print(f"Set output default to: {cfg['output_default']}")

def cmd_run(args):
    cfg = load_config()
    if not args.input:
        print("error: -i/--input is required", file=sys.stderr); sys.exit(2)
    input_mp3 = Path(args.input).expanduser()
    if not input_mp3.exists():
        print(f"error: input file not found: {input_mp3}", file=sys.stderr); sys.exit(2)
    outdir = ensure_outdir(args.output, cfg)

    # SINGLE CLIP (no concat)
    if args.start and args.end and not args.concat:
        start_s = parse_time(args.start); end_s = parse_time(args.end)
        name = sanitize_filename(args.name) if args.name else f"{input_mp3.stem}_{int(start_s)}-{int(end_s)}"
        out_path = outdir / f"{name}.mp3"
        # edge_fade can be applied on single clips too; mono/cbr also respected
        copy = args.copy and args.edge_fade <= 0 and not args.mono and not args.cbr
        run_ffmpeg_cut(
            input_mp3, start_s, end_s, out_path,
            title=args.name or name,
            comment=args.info,
            copy=copy,
            edge_fade=max(0.0, args.edge_fade),
            cbr=args.cbr
        )
        # If mono requested but we stream-copied, we need a second pass â€” but copy was gated above.
        if args.mono and copy:
            print("note: --mono requires re-encode; ignoring --copy for single clip")
        print(f"wrote {out_path}")
        return

    # BATCH / CONCAT
    if args.file:
        batch_path = Path(args.file).expanduser()
        if not batch_path.exists():
            print(f"error: batch file not found: {batch_path}", file=sys.stderr); sys.exit(2)

        default_desc, clips = parse_batch_file(batch_path)
        if not clips:
            print("no clips found in batch file", file=sys.stderr); sys.exit(2)

        # Prepare cut parts
        tmp_dir = None
        if args.concat:
            tmp_dir = Path(tempfile.mkdtemp(prefix="podmix_", dir=str(outdir)))
        try:
            parts: List[Path] = []
            for i, c in enumerate(clips, 1):
                # Decide where parts go:
                if args.concat:
                    part_path = (tmp_dir / f"part_{i:02d}.mp3")
                else:
                    # per-clip output names (batch no-concat)
                    part_path = derive_outfile(outdir, c.get("name"), i)

                # For parts, we can stream copy if allowed and no edge_fade requested.
                part_copy = args.copy and args.edge_fade <= 0 and not args.cbr
                run_ffmpeg_cut(
                    input_mp3, c["start_s"], c["end_s"], part_path,
                    title=part_path.stem,
                    comment=c.get("description") or args.info or default_desc,
                    copy=part_copy,
                    edge_fade=max(0.0, args.edge_fade),
                    cbr=args.cbr
                )
                parts.append(part_path)
                if not args.concat:
                    print(f"wrote {part_path}")

            if not args.concat:
                # Done: wrote individual files
                return

            # CONCAT PATH
            merged_name = sanitize_filename(args.name) if args.name else f"{input_mp3.stem}_highlights"
            merged_out = outdir / f"{merged_name}.mp3"

            # If both xfade and gap provided, prefer xfade
            if args.gap > 0 and args.xfade > 0:
                print("note: both --xfade and --gap provided; using --xfade and ignoring --gap")

            if args.xfade > 0 and len(parts) >= 2:
                # Crossfade chain (always re-encodes final)
                ffmpeg_concat_xfade(
                    parts=parts,
                    out_path=merged_out,
                    xfade=args.xfade,
                    shape=args.xfade_shape,
                    title=merged_name,
                    comment=args.info or default_desc,
                    cbr=args.cbr,
                    mono=args.mono,
                    add_limiter=True,
                    loudnorm_i=(args.loudnorm if args.loudnorm is not None else None)
                )
                print(f"wrote {merged_out}")
            else:
                # Plain concat via demuxer; optionally insert gaps (silence files)
                if args.gap > 0 and len(parts) >= 2:
                    # interleave silence files
                    interleaved: List[Path] = []
                    for idx, p in enumerate(parts):
                        interleaved.append(p)
                        if idx < len(parts) - 1:
                            sfile = tmp_dir / f"silence_{idx:02d}.mp3"
                            make_silence_mp3(sfile, args.gap, cbr=args.cbr, mono=False)
                            interleaved.append(sfile)
                    parts = interleaved

                # Build concat list file
                list_file = tmp_dir / "concat.txt"
                with list_file.open("w", encoding="utf-8") as lf:
                    for p in parts:
                        lf.write(f"file '{p.as_posix()}'\n")

                # Optional post-filter on entire merged (limiter and/or loudnorm)
                filter_chain = []
                # Always nice to have gentle limiter
                filter_chain.append("alimiter=limit=0.90")
                if args.loudnorm is not None:
                    filter_chain.append(f"loudnorm=I={args.loudnorm}:TP=-1.5:LRA=11")
                filter_a = ",".join(filter_chain) if filter_chain else None

                ffmpeg_concat_list(
                    list_file=list_file,
                    out_path=merged_out,
                    copy=args.copy and not filter_a and not args.mono and not args.cbr,
                    title=merged_name,
                    comment=args.info or default_desc,
                    filter_a=filter_a,
                    cbr=args.cbr,
                    mono=args.mono
                )
                print(f"wrote {merged_out}")

            if args.keep_clips:
                clips_dir = outdir / f"{merged_name}_parts"
                clips_dir.mkdir(exist_ok=True)
                for p in tmp_dir.glob("part_*.mp3"):
                    p.replace(clips_dir / p.name)
                for p in tmp_dir.glob("silence_*.mp3"):
                    p.replace(clips_dir / p.name)
                print(f"kept parts in {clips_dir}")

        finally:
            # cleanup temp dir if not keeping clips
            if tmp_dir and (not args.keep_clips):
                for p in tmp_dir.glob("*"):
                    try: p.unlink()
                    except: pass
                try: tmp_dir.rmdir()
                except: pass
        return

    print("error: provide --start and --end for a single clip, or -f/--file for batch/concat.", file=sys.stderr)
    sys.exit(2)

# ---------------- CLI ----------------

def make_parser():
    p = argparse.ArgumentParser(
        prog=APP_NAME,
        description="Cut podcast clips from MP3s; batch, concat, crossfade, gaps, loudness."
    )
    sub = p.add_subparsers(dest="cmd")

    # run
    pr = sub.add_parser("run", help="Run podmix")
    pr.add_argument("-i","--input", help="Input MP3 file")
    pr.add_argument("--start", help="Start time (M:SS, H:MM:SS, or seconds)")
    pr.add_argument("--end", help="End time (M:SS, H:MM:SS, or seconds)")
    pr.add_argument("-o","--output", help="Output directory")
    pr.add_argument("--name", help="Output filename (single clip) or merged name with --concat")
    pr.add_argument("--info", help="Optional description/notes for metadata")
    pr.add_argument("-f","--file", help="Batch file (CSV) with rows: start,end,name,description")
    pr.add_argument("--copy", action="store_true",
                    help="Try stream copy (fast, less accurate; disabled if filters/mono/cbr needed)")
    pr.add_argument("--concat", action="store_true", help="Concatenate all batch clips into one MP3")
    pr.add_argument("--keep-clips", action="store_true", help="With --concat, keep the intermediate per-range clips")
    # audio shaping
    pr.add_argument("--xfade", type=float, default=1.0, help="Crossfade seconds between clips (with --concat)")
    pr.add_argument("--xfade-shape", choices=["tri","log","exp","qsin"], default="tri",
                    help="Crossfade curve shape")
    pr.add_argument("--gap", type=float, default=0.0, help="Silence (seconds) inserted between clips (ignored if --xfade>0)")
    pr.add_argument("--edge-fade", type=float, default=0.02, help="Fade-in/out (seconds) applied to each cut part")
    pr.add_argument("--loudnorm", type=float, default=None,
                    help="Target LUFS for final loudness (e.g., -16 for podcasts). Re-encodes final.")
    pr.add_argument("--mono", action="store_true", help="Downmix final output to mono")
    pr.add_argument("--cbr", type=str, default=None, help="Force CBR bitrate for encoded outputs (e.g., 192k)")
    pr.set_defaults(func=cmd_run)

    # convenience: root behaves like run
    p.add_argument("-i","--input", help=argparse.SUPPRESS)
    p.add_argument("--start", help=argparse.SUPPRESS)
    p.add_argument("--end", help=argparse.SUPPRESS)
    p.add_argument("-o","--output", help=argparse.SUPPRESS)
    p.add_argument("--name", help=argparse.SUPPRESS)
    p.add_argument("--info", help=argparse.SUPPRESS)
    p.add_argument("-f","--file", help=argparse.SUPPRESS)
    p.add_argument("--copy", action="store_true", help=argparse.SUPPRESS)
    p.add_argument("--concat", action="store_true", help=argparse.SUPPRESS)
    p.add_argument("--keep-clips", action="store_true", help=argparse.SUPPRESS)
    p.add_argument("--xfade", type=float, default=1.0, help=argparse.SUPPRESS)
    p.add_argument("--xfade-shape", choices=["tri","log","exp","qsin"], default="tri", help=argparse.SUPPRESS)
    p.add_argument("--gap", type=float, default=0.0, help=argparse.SUPPRESS)
    p.add_argument("--edge-fade", type=float, default=0.02, help=argparse.SUPPRESS)
    p.add_argument("--loudnorm", type=float, default=None, help=argparse.SUPPRESS)
    p.add_argument("--mono", action="store_true", help=argparse.SUPPRESS)
    p.add_argument("--cbr", type=str, default=None, help=argparse.SUPPRESS)

    # set
    ps = sub.add_parser("set", help="Set defaults")
    ps.add_argument("--output-default", help="Default output directory")
    ps.set_defaults(func=cmd_set)
    return p

def main(argv=None):
    argv = sys.argv[1:] if argv is None else argv
    parser = make_parser()
    if argv and argv[0] not in {"run","set"}:
        argv = ["run"] + argv
    args = parser.parse_args(argv)
    if not hasattr(args, "func"):
        parser.print_help()
        return 2
    try:
        return args.func(args) or 0
    except (ValueError, RuntimeError) as e:
        print(f"error: {e}", file=sys.stderr)
        return 1

if __name__ == "__main__":
    sys.exit(main())