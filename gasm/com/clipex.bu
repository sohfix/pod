#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
clipex — cut podcast/music clips; batch, concat, crossfade, gaps, loudness, and work in named spaces.

Quick examples:
  # Single clip with safe edges (millisecond precision supported)
  clipex -i INPUT.mp3 --start 3:50.250 --end 4:50.750 --name intro --edge-fade 0.02

  # Play clip after cutting
  clipex -i INPUT.mp3 --start 10 --end 20 --name sample --play

  # Batch (CSV) → individual files
  clipex -i INPUT.mp3 -f clips.csv

  # Batch → one highlight reel with 1.0s crossfades + loudness target
  clipex -i INPUT.mp3 -f clips.csv --concat --name highlight_reel --xfade 1.0 --loudnorm -16

  # Concat existing clips (skip cutting)
  clipex --parts clipA.mp3 clipB.mp3 clipC.mp3 --concat --name mega_mix --xfade 0.75 --loudnorm -16

  # Multi-input CSV with per-row source
  clipex -i ep1.mp3 -i ep2.mp3 -i ep3.mp3 -f clips.csv --concat --name supercut --xfade 1.0

  # Set a default output directory
  clipex set --output-default ~/media/audio/clipex

  # Work in spaces (namespaces)
  clipex space create mypod
  clipex space set --in ~/Podcasts/mypod --out ~/Clips/mypod
  clipex space start mypod
  clipex -i episode01.mp3 -f cuts.csv --concat --name ep01_supercut   # uses space I/O by default
  clipex space list
  clipex space end
"""

import argparse, csv, json, os, re, subprocess, sys, tempfile, textwrap, shutil, platform
from pathlib import Path
from typing import Optional, Tuple, List, Dict, Any

APP_NAME   = "clipex"
APP_DESC   = "Cut podcast/music clips from MP3s; batch, concat, crossfade, gaps, loudness, and spaces."
APP_VER    = "1.7.0"

CONFIG_DIR = Path(os.environ.get("XDG_CONFIG_HOME", Path.home() / "apps/.app-data/.config-files")) / APP_NAME
CONFIG_PATH= CONFIG_DIR / "config.json"

# Globals toggled by CLI
VERBOSE   = False
OVERWRITE = False

# ---------- Help & UX ----------

class _SmartFormatter(argparse.ArgumentDefaultsHelpFormatter, argparse.RawTextHelpFormatter):
    """Shows defaults + preserves newlines/indent."""
    pass

def _dedent(s: str) -> str:
    return textwrap.dedent(s).strip("\n")

EXAMPLES_TEXT = _dedent(f"""
General:
  {APP_NAME} --help
  {APP_NAME} --version
  {APP_NAME} --examples
  {APP_NAME} help run
  {APP_NAME} help set
  {APP_NAME} help space

Single clip:
  # Times accept M:SS(.ms), H:MM:SS(.ms), or seconds(.ms)
  {APP_NAME} -i INPUT.mp3 --start "3:50.250" --end "4:50.750" --name intro
  {APP_NAME} -i INPUT.mp3 --start 235.1 --end 300.9 --name funny_bit --edge-fade 0.02
  {APP_NAME} -i INPUT.mp3 --start 3:55 --end 4:55.500 --name teaser --mono --cbr 192k --play

Batch (CSV format):
  # clips.csv
  #default, Highlights from the episode
  start,end,name,description
  3:55,4:55.250,hot_take,#default
  2:35.100,3:33.900,funny_bit,Hosts crack up
  420.0,505.5,,

  {APP_NAME} -i INPUT.mp3 -f clips.csv

Multi-input CSV (per-row 'source' optional):
  # clips.csv
  #default, Supercut across three pods
  start,end,name,description,source
  3:55,4:55.250,ep1_hot_take,#default,ep1.mp3
  2:35.100,3:33.900,ep2_funny,Hosts crack up,ep2.mp3
  420.0,505.5,ep3_reflection,,ep3.mp3

  {APP_NAME} -i ep1.mp3 -i ep2.mp3 -i ep3.mp3 -f clips.csv --concat --name supercut --xfade 1.0

Concat (one highlight reel):
  {APP_NAME} -i INPUT.mp3 -f clips.csv --concat --name highlight_reel

Concat + crossfade + loudness:
  {APP_NAME} -i INPUT.mp3 -f clips.csv --concat --name highlight_reel --xfade 1.0 --loudnorm -16

Concat + gaps (no crossfade):
  {APP_NAME} -i INPUT.mp3 -f clips.csv --concat --gap 0.25 --name teaser_mix

Keep the cut parts too:
  {APP_NAME} -i INPUT.mp3 -f clips.csv --concat --xfade 1.0 --keep-clips

Concat existing clips (skip cutting):
  {APP_NAME} --parts clipA.mp3 clipB.mp3 clipC.mp3 --concat --name mega_mix --xfade 0.75 --loudnorm -16

Set defaults:
  {APP_NAME} set --output-default ~/ClipexClips

Spaces:
  {APP_NAME} space create myshow
  {APP_NAME} space set --in ~/Podcasts/myshow --out ~/Clips/myshow
  {APP_NAME} space start myshow
  {APP_NAME} -i ep001.mp3 --start 30 --end 90 --name opener
  {APP_NAME} space list
  {APP_NAME} space end
""")

def print_examples_and_exit():
    print(EXAMPLES_TEXT)
    sys.exit(0)

def print_topic_help_and_exit(parser: argparse.ArgumentParser, topic: Optional[str]):
    # topic can be "run" or "set" or "space" or None
    if not topic or topic.lower() not in {"run", "set", "space"}:
        parser.print_help()
        sys.exit(0)
    # find the subparser by name and print its help
    subparsers_action = next(a for a in parser._actions if isinstance(a, argparse._SubParsersAction))
    sp = subparsers_action.choices[topic.lower()]
    sp.print_help()
    sys.exit(0)

# ---------- Config & Spaces ----------

def load_config() -> dict:
    if CONFIG_PATH.exists():
        try:
            return json.loads(CONFIG_PATH.read_text())
        except Exception:
            pass
    return {}

def save_config(cfg: dict) -> None:
    CONFIG_DIR.mkdir(parents=True, exist_ok=True)
    CONFIG_PATH.write_text(json.dumps(cfg, indent=2))

def get_spaces(cfg: Dict[str, Any]) -> Dict[str, Any]:
    return cfg.setdefault("spaces", {})

def get_current_space(cfg: Dict[str, Any]) -> Optional[str]:
    return cfg.get("current_space")

def set_current_space(cfg: Dict[str, Any], name: Optional[str]) -> None:
    if name is None:
        cfg.pop("current_space", None)
    else:
        cfg["current_space"] = name
    save_config(cfg)

def ensure_outdir(path: Optional[str], cfg: dict) -> Path:
    """
    Resolves the output directory in priority:
      1) --output
      2) current space's 'out'
      3) configured default (clipex set --output-default DIR)
      4) current directory
    Creates the directory if missing.
    """
    out = None
    if path:
        out = Path(path).expanduser()
    else:
        cur = get_current_space(cfg)
        if cur:
            out = Path(get_spaces(cfg).get(cur, {}).get("out", "")) if get_spaces(cfg).get(cur, {}).get("out") else None
        if not out:
            out = Path(cfg.get("output_default", "."))

    out.mkdir(parents=True, exist_ok=True)
    return out

def resolve_input_path(user_path: str, cfg: dict) -> Path:
    """
    Resolve an input path, trying as given; if not found and current space has 'in', try under that.
    """
    p = Path(user_path).expanduser()
    if p.exists():
        return p
    cur = get_current_space(cfg)
    if cur:
        in_base = get_spaces(cfg).get(cur, {}).get("in")
        if in_base:
            p2 = Path(in_base).expanduser() / user_path
            if p2.exists():
                return p2
    return p  # will be validated by callers

# ---------- ffmpeg helpers ----------

def ffmpeg_base_args() -> List[str]:
    args = ["-hide_banner"]
    args += ["-loglevel", "info" if VERBOSE else "error"]
    if OVERWRITE:
        args += ["-y"]
    return args

def run_subprocess(cmd: List[str]) -> int:
    if VERBOSE:
        print(">>", " ".join(cmd))
    return subprocess.run(cmd).returncode

# ---------- Utilities ----------

# Updated to support milliseconds:
# - M:SS(.ms)
# - H:MM:SS(.ms)
# - seconds(.ms)
TIME_PATTERNS = [
    re.compile(r"^(?P<m>\d+):(?P<s>[0-5]?\d(?:\.\d+)?)$"),                 # M:SS(.ms)
    re.compile(r"^(?P<h>\d+):(?P<m>[0-5]?\d):(?P<s>[0-5]?\d(?:\.\d+)?)$"), # H:MM:SS(.ms)
    re.compile(r"^(?P<s>\d+(?:\.\d+)?)$"),                                 # seconds(.ms)
]

def parse_time(ts: str) -> float:
    """
    Parse time strings with optional milliseconds.
    Accepts: M:SS(.ms) | H:MM:SS(.ms) | seconds(.ms)
    """
    s = ts.strip()
    for pat in TIME_PATTERNS:
        m = pat.match(s)
        if m:
            h = float(m.groupdict().get("h") or 0)
            m_ = float(m.groupdict().get("m") or 0)
            s_ = float(m.groupdict().get("s") or 0)
            return h * 3600.0 + m_ * 60.0 + s_
    raise ValueError(f"Invalid time format: {ts!r}  (use M:SS(.ms), H:MM:SS(.ms), or seconds(.ms))")

def sanitize_filename(name: str) -> str:
    return re.sub(r'[\\/:*?"<>|]+', "_", name).strip()

def choose_encode_args(cbr: Optional[str], mono: bool) -> List[str]:
    """
    Audio encode args for final renders (or parts when re-encoding).
    Default: VBR -q:a 2. If cbr like '192k', use -b:a 192k. --mono downmixes.
    """
    args = ["-acodec", "libmp3lame"]
    if cbr:
        args += ["-b:a", str(cbr)]
    else:
        args += ["-q:a", "2"]  # good VBR for podcasts
    if mono:
        args += ["-ac", "1"]
    return args

# ---------- Player ----------

def find_player() -> Optional[List[str]]:
    """
    Returns a command list for a suitable audio player (blocking preferred).
    Tries: ffplay -autoexit, afplay (macOS), mpg123, cvlc, play (sox), powershell WMPlayer fallback.
    """
    if shutil.which("ffplay"):
        return ["ffplay", *ffmpeg_base_args(), "-autoexit"]
    if platform.system() == "Darwin" and shutil.which("afplay"):
        return ["afplay"]
    if shutil.which("mpg123"):
        return ["mpg123", "-q"]
    if shutil.which("cvlc"):
        return ["cvlc", "--play-and-exit", "--quiet"]
    if shutil.which("play"):  # from sox
        return ["play", "-q"]
    # Windows basic fallback using start (non-blocking) – still acceptable
    if platform.system() == "Windows":
        return ["cmd", "/c", "start", ""]
    return None

def play_file(path: Path) -> None:
    cmd = find_player()
    if not cmd:
        print(f"note: no suitable audio player found to play {path}", file=sys.stderr)
        return
    run_subprocess(cmd + [str(path)])

# ---------- Cutting & parsing ----------

def run_ffmpeg_cut(
    input_mp3: Path,
    start_s: float,
    end_s: float,
    out_path: Path,
    title: Optional[str] = None,
    comment: Optional[str] = None,
    copy: bool = False,
    edge_fade: float = 0.0,
    cbr: Optional[str] = None,
) -> None:
    """
    Cut a segment from input. If edge_fade>0, apply tiny fades to prevent clicks (re-encode).
    If copy=True and edge_fade>0 or cbr set, copy is ignored (we re-encode).
    """
    if end_s <= start_s:
        raise ValueError("end must be greater than start")
    duration = end_s - start_s

    meta = []
    if title:   meta += ["-metadata", f"title={title}"]
    if comment: meta += ["-metadata", f"comment={comment}"]

    cmd = [
        "ffmpeg", *ffmpeg_base_args(),
        "-ss", f"{start_s:.3f}", "-t", f"{duration:.3f}",
        "-i", str(input_mp3),
    ]

    if copy and edge_fade <= 0 and not cbr:
        codec_args = ["-c", "copy"]
        filter_args: List[str] = []
    else:
        codec_args = choose_encode_args(cbr=cbr, mono=False)
        filter_chain = []
        if edge_fade > 0:
            st_out = max(0.0, duration - edge_fade)
            filter_chain.append(f"afade=t=in:st=0:d={edge_fade}")
            filter_chain.append(f"afade=t=out:st={st_out:.3f}:d={edge_fade}")
        filter_args = ["-af", ",".join(filter_chain)] if filter_chain else []
        if copy and (edge_fade > 0 or cbr):
            print(f"note: re-encoding {out_path.name} (copy disabled by --edge-fade/--cbr)")

    cmd += filter_args + codec_args + meta + [str(out_path)]
    if run_subprocess(cmd) != 0:
        raise RuntimeError(f"ffmpeg failed for {out_path.name}")

def sniff_has_header(row: List[str]) -> bool:
    joined = ",".join(c.strip().lower() for c in row)
    return "start" in joined and "end" in joined

def parse_batch_file(path: Path) -> Tuple[str, List[dict]]:
    """
    CSV format (now allows optional 'source' per row):
      #default, Your default description (optional; first such line wins)
      start,end,name,description[,source]
      3:55.000,4:55.250,hot_take,#default,ep1.mp3
      2:35.100,3:33.900,funny_bit,Hosts crack up,ep2.mp3
      420.0,505.5,,,
    """
    default_desc = ""
    clips: List[dict] = []
    with path.open(newline="", encoding="utf-8") as f:
        reader = csv.reader(f)
        first_row = None
        for raw in reader:
            if not raw or (len(raw) == 1 and not raw[0].strip()):
                continue
            if raw[0].strip().startswith("#default"):
                if len(raw) >= 2:
                    default_desc = ",".join(raw[1:]).strip()
                continue
            if raw[0].strip().startswith("#"):
                continue
            if first_row is None:
                first_row = raw
                if sniff_has_header(first_row):
                    first_row = None
                    continue
            row = raw if first_row is None else first_row
            first_row = None

            # normalize to up to 5 cols: start,end,name,description,source?
            row = (row + ["", "", "", "", ""])[:5]
            start, end, name, desc, source = [c.strip() for c in row[:5]]
            if not start or not end:
                raise ValueError(f"Batch row missing start/end: {row}")
            start_s = parse_time(start); end_s = parse_time(end)
            nm = sanitize_filename(name) if name else ""
            description = default_desc if (desc == "#default" or desc == "") else desc
            clips.append({
                "start_s": start_s,
                "end_s": end_s,
                "name": nm,
                "description": description,
                "source": source,
            })
    return default_desc, clips

def derive_outfile(base_dir: Path, base_name: Optional[str], idx: int) -> Path:
    stem = sanitize_filename(base_name) if base_name else f"clip_{idx:02d}"
    return base_dir / f"{stem}.mp3"

# ---------- Concat helpers ----------

def make_silence_mp3(path: Path, duration: float, cbr: Optional[str], mono: bool) -> None:
    """Create a silent MP3 of given duration (seconds) using anullsrc."""
    if duration <= 0:
        return
    cmd = [
        "ffmpeg", *ffmpeg_base_args(),
        "-f", "lavfi", "-t", f"{duration:.3f}",
        "-i", "anullsrc=channel_layout=stereo:sample_rate=44100",
        *choose_encode_args(cbr=cbr, mono=mono),
        str(path)
    ]
    if run_subprocess(cmd) != 0:
        raise RuntimeError("failed to generate silence clip")

def build_xfade_filter(n_parts: int, xfade: float, shape: str,
                       add_limiter: bool, loudnorm_i: Optional[float]) -> Tuple[str, str]:
    """
    Build a filter_complex acrossfade chain.
    Returns (filter_complex, final_label).
    """
    if n_parts == 1:
        return "", "0:a"

    shape = (shape or "tri").lower()
    if shape not in {"tri", "exp", "log", "qsin"}:
        shape = "tri"

    filters = []
    prev = "0:a"
    for i in range(1, n_parts):
        cur = f"{i}:a"
        out = f"af{i}"
        filters.append(f"[{prev}][{cur}]acrossfade=d={xfade}:c1={shape}:c2={shape}[{out}]")
        prev = out

    final_label = prev
    if add_limiter:
        filters.append(f"[{final_label}]alimiter=limit=0.90[lim]")
        final_label = "lim"
    if loudnorm_i is not None:
        filters.append(f"[{final_label}]loudnorm=I={loudnorm_i}:TP=-1.5:LRA=11[ln]")
        final_label = "ln"

    return ";".join(filters), final_label

def ffmpeg_concat_list(list_file: Path, out_path: Path, copy: bool,
                       title: Optional[str], comment: Optional[str],
                       filter_a: Optional[str], cbr: Optional[str], mono: bool) -> None:
    """
    Concat demuxer path. If filter_a provided or mono/cbr requested, we re-encode; else stream copy.
    """
    meta = []
    if title:   meta += ["-metadata", f"title={title}"]
    if comment: meta += ["-metadata", f"comment={comment}"]

    cmd = ["ffmpeg", *ffmpeg_base_args(),
           "-f", "concat", "-safe", "0", "-i", str(list_file)]

    must_encode = bool(filter_a) or mono or not copy or bool(cbr)
    if must_encode:
        if filter_a:
            cmd += ["-filter:a", filter_a]
        cmd += choose_encode_args(cbr=cbr, mono=mono)
    else:
        cmd += ["-c", "copy"]

    cmd += meta + [str(out_path)]
    if run_subprocess(cmd) != 0:
        raise RuntimeError(f"ffmpeg concat failed for {out_path.name}")

def ffmpeg_concat_xfade(parts: List[Path], out_path: Path, xfade: float, shape: str,
                        title: Optional[str], comment: Optional[str],
                        cbr: Optional[str], mono: bool,
                        add_limiter: bool, loudnorm_i: Optional[float]) -> None:
    """
    Multi-input, filter_complex acrossfade with optional limiter/loudnorm.
    Always re-encodes the final output.
    """
    cmd = ["ffmpeg", *ffmpeg_base_args()]
    for p in parts:
        cmd += ["-i", str(p)]

    filter_complex, final_label = build_xfade_filter(
        n_parts=len(parts), xfade=xfade, shape=shape,
        add_limiter=add_limiter, loudnorm_i=loudnorm_i
    )

    if filter_complex:
        cmd += ["-filter_complex", filter_complex, "-map", f"[{final_label}]"]
    else:
        cmd += ["-map", "0:a"]

    cmd += choose_encode_args(cbr=cbr, mono=mono)
    if title:   cmd += ["-metadata", f"title={title}"]
    if comment: cmd += ["-metadata", f"comment={comment}"]
    cmd += [str(out_path)]
    if run_subprocess(cmd) != 0:
        raise RuntimeError(f"ffmpeg xfade failed for {out_path.name}")

# ---------- Commands ----------

def cmd_set(args):
    """Implements `clipex set`."""
    cfg = load_config()
    if args.output_default:
        cfg["output_default"] = str(Path(args.output_default).expanduser())
        save_config(cfg)
        print(f"Set output default to: {cfg['output_default']}")

def _validate_inputs_exist(inputs: List[Path]):
    for p in inputs:
        if not p.exists():
            print(f"error: input file not found: {p}", file=sys.stderr); sys.exit(2)

def cmd_run(args):
    """Implements `clipex run` (default)."""
    cfg = load_config()
    if args.examples:
        print_examples_and_exit()

    # guard: incompatible combos
    if args.parts and (args.file or args.start or args.end):
        print("error: --parts cannot be combined with --start/--end or -f/--file", file=sys.stderr); sys.exit(2)

    # resolve inputs list (may be None, 1+, or unused when every CSV row has a source)
    inputs: List[Path] = []
    if args.input:
        for i in args.input:
            p = resolve_input_path(i, cfg)
            if not p.exists():
                print(f"error: input file not found: {p}", file=sys.stderr); sys.exit(2)
            inputs.append(p)

    outdir = ensure_outdir(args.output, cfg)

    # SINGLE CLIP (no concat)
    if args.start and args.end and not args.concat and not args.parts and not args.file:
        if len(inputs) != 1:
            print("error: single-clip mode requires exactly one -i/--input", file=sys.stderr); sys.exit(2)
        input_mp3 = inputs[0]
        start_s = parse_time(args.start); end_s = parse_time(args.end)
        name = sanitize_filename(args.name) if args.name else f"{input_mp3.stem}_{int(start_s)}-{int(end_s)}"
        out_path = outdir / f"{name}.mp3"
        # stream copy only if no re-encode features requested
        copy = args.copy and args.edge_fade <= 0 and not args.mono and not args.cbr
        run_ffmpeg_cut(
            input_mp3, start_s, end_s, out_path,
            title=args.name or name,
            comment=args.info,
            copy=copy,
            edge_fade=max(0.0, args.edge_fade),
            cbr=args.cbr
        )
        if args.mono and copy:
            print("note: --mono requires re-encode; ignoring --copy for single clip")
        print(f"wrote {out_path}")
        if args.play:
            play_file(out_path)
        return

    # PARTS-ONLY CONCAT: build a supercut from existing clip files
    if args.parts:
        parts = []
        for mp in args.parts:
            p = resolve_input_path(mp, cfg)
            if not p.exists():
                print(f"error: part not found: {p}", file=sys.stderr); sys.exit(2)
            parts.append(p)

        if not args.concat:
            # if user forgot --concat, assume they wanted one file
            args.concat = True

        merged_name = sanitize_filename(args.name) if args.name else "supercut"
        merged_out = outdir / f"{merged_name}.mp3"

        if args.xfade > 0 and len(parts) >= 2:
            ffmpeg_concat_xfade(
                parts=parts,
                out_path=merged_out,
                xfade=args.xfade,
                shape=args.xfade_shape,
                title=merged_name,
                comment=args.info,
                cbr=args.cbr,
                mono=args.mono,
                add_limiter=True,
                loudnorm_i=(args.loudnorm if args.loudnorm is not None else None)
            )
            print(f"wrote {merged_out}")
        else:
            # optionally insert gaps
            tmp_dir = Path(tempfile.mkdtemp(prefix="clipex_", dir=str(outdir)))
            try:
                if args.gap > 0 and len(parts) >= 2:
                    interleaved = []
                    for idx, p in enumerate(parts):
                        interleaved.append(p)
                        if idx < len(parts) - 1:
                            sfile = tmp_dir / f"silence_{idx:02d}.mp3"
                            make_silence_mp3(sfile, args.gap, cbr=args.cbr, mono=False)
                            interleaved.append(sfile)
                    parts = interleaved

                list_file = tmp_dir / "concat.txt"
                with list_file.open("w", encoding="utf-8") as lf:
                    for p in parts:
                        lf.write(f"file '{p.as_posix()}'\n")

                # Post-filter chain for final (limiter always on; loudnorm optional)
                filter_chain = ["alimiter=limit=0.90"]
                if args.loudnorm is not None:
                    filter_chain.append(f"loudnorm=I={args.loudnorm}:TP=-1.5:LRA=11")
                filter_a = ",".join(filter_chain) if filter_chain else None

                ffmpeg_concat_list(
                    list_file=list_file,
                    out_path=merged_out,
                    copy=args.copy and not filter_a and not args.mono and not args.cbr,
                    title=merged_name,
                    comment=args.info,
                    filter_a=filter_a,
                    cbr=args.cbr,
                    mono=args.mono
                )
                print(f"wrote {merged_out}")
            finally:
                for p in tmp_dir.glob("*"):
                    try: p.unlink()
                    except: pass
                try: tmp_dir.rmdir()
                except: pass
        if args.play:
            play_file(merged_out)
        return

    # BATCH / CONCAT
    if args.file:
        batch_path = resolve_input_path(args.file, cfg)
        if not batch_path.exists():
            print(f"error: batch file not found: {batch_path}", file=sys.stderr); sys.exit(2)

        default_desc, clips = parse_batch_file(batch_path)
        if not clips:
            print("no clips found in batch file", file=sys.stderr); sys.exit(2)

        # Prepare cut parts
        tmp_dir = None
        if args.concat:
            tmp_dir = Path(tempfile.mkdtemp(prefix="clipex_", dir=str(outdir)))
        try:
            parts: List[Path] = []
            for i, c in enumerate(clips, 1):
                # resolve source for this row:
                src_text = c.get("source") or ""
                if src_text:
                    src_path = resolve_input_path(src_text, cfg)
                    if not src_path.exists():
                        print(f"error: source not found for row {i}: {src_path}", file=sys.stderr); sys.exit(2)
                    input_mp3 = src_path
                else:
                    if not inputs:
                        print("error: no input provided for row without 'source' (use -i/--input or add 'source' in CSV)", file=sys.stderr); sys.exit(2)
                    input_mp3 = inputs[0]

                if args.concat:
                    part_path = (tmp_dir / f"part_{i:02d}.mp3")
                else:
                    part_path = derive_outfile(outdir, c.get("name"), i)

                part_copy = args.copy and args.edge_fade <= 0 and not args.cbr
                run_ffmpeg_cut(
                    input_mp3, c["start_s"], c["end_s"], part_path,
                    title=part_path.stem,
                    comment=c.get("description") or args.info or default_desc,
                    copy=part_copy,
                    edge_fade=max(0.0, args.edge_fade),
                    cbr=args.cbr
                )
                parts.append(part_path)
                if not args.concat:
                    print(f"wrote {part_path}")

            if not args.concat:
                if args.play and parts:
                    print("note: --play with batch (no --concat) will play only the last written clip.")
                    play_file(parts[-1])
                return

            # CONCAT PATH
            merged_name = sanitize_filename(args.name) if args.name else f"{Path(inputs[0]).stem if inputs else 'highlights'}_highlights"
            merged_out = outdir / f"{merged_name}.mp3"

            # If both xfade and gap provided, prefer xfade
            if args.gap > 0 and args.xfade > 0:
                print("note: both --xfade and --gap provided; using --xfade and ignoring --gap")

            if args.xfade > 0 and len(parts) >= 2:
                ffmpeg_concat_xfade(
                    parts=parts,
                    out_path=merged_out,
                    xfade=args.xfade,
                    shape=args.xfade_shape,
                    title=merged_name,
                    comment=args.info or default_desc,
                    cbr=args.cbr,
                    mono=args.mono,
                    add_limiter=True,
                    loudnorm_i=(args.loudnorm if args.loudnorm is not None else None)
                )
                print(f"wrote {merged_out}")
            else:
                # Plain concat via demuxer; optionally insert gaps (silence files)
                if args.gap > 0 and len(parts) >= 2:
                    interleaved: List[Path] = []
                    for idx, p in enumerate(parts):
                        interleaved.append(p)
                        if idx < len(parts) - 1:
                            sfile = tmp_dir / f"silence_{idx:02d}.mp3"
                            make_silence_mp3(sfile, args.gap, cbr=args.cbr, mono=False)
                            interleaved.append(sfile)
                    parts = interleaved

                list_file = tmp_dir / "concat.txt"
                with list_file.open("w", encoding="utf-8") as lf:
                    for p in parts:
                        lf.write(f"file '{p.as_posix()}'\n")

                # Post-filter chain for final (limiter always on; loudnorm optional)
                filter_chain = ["alimiter=limit=0.90"]
                if args.loudnorm is not None:
                    filter_chain.append(f"loudnorm=I={args.loudnorm}:TP=-1.5:LRA=11")
                filter_a = ",".join(filter_chain) if filter_chain else None

                ffmpeg_concat_list(
                    list_file=list_file,
                    out_path=merged_out,
                    copy=args.copy and not filter_a and not args.mono and not args.cbr,
                    title=merged_name,
                    comment=args.info or default_desc,
                    filter_a=filter_a,
                    cbr=args.cbr,
                    mono=args.mono
                )
                print(f"wrote {merged_out}")

            if args.keep_clips:
                clips_dir = outdir / f"{merged_name}_parts"
                clips_dir.mkdir(exist_ok=True)
                for p in tmp_dir.glob("part_*.mp3"):
                    p.replace(clips_dir / p.name)
                for p in tmp_dir.glob("silence_*.mp3"):
                    p.replace(clips_dir / p.name)
                print(f"kept parts in {clips_dir}")

            if args.play:
                play_file(merged_out)

        finally:
            if tmp_dir and (not args.keep_clips):
                for p in tmp_dir.glob("*"):
                    try: p.unlink()
                    except: pass
                try: tmp_dir.rmdir()
                except: pass
        return

    print("error: provide --start and --end for a single clip, or -f/--file for batch/concat, or --parts for existing clips.", file=sys.stderr)
    sys.exit(2)

# ---------- Spaces subcommands ----------

def cmd_space(args):
    """
    clipex space [create NAME | start NAME | end [NAME] | set (--in DIR | --out DIR | --list-io) | list | change NAME | delete NAME]
    """
    cfg = load_config()
    spaces = get_spaces(cfg)

    if args.action == "create":
        name = args.name
        if not name:
            print("error: space create requires a NAME", file=sys.stderr); sys.exit(2)
        if name in spaces:
            print(f"error: space '{name}' already exists", file=sys.stderr); sys.exit(2)
        spaces[name] = {"in": "", "out": ""}
        save_config(cfg)
        print(f"created space '{name}'")

    elif args.action in {"start", "change"}:
        name = args.name
        if not name:
            print(f"error: space {args.action} requires a NAME", file=sys.stderr); sys.exit(2)
        if name not in spaces:
            print(f"error: space '{name}' not found", file=sys.stderr); sys.exit(2)
        set_current_space(cfg, name)
        print(f"current space: {name}")

    elif args.action == "end":
        name = args.name
        cur = get_current_space(cfg)
        if name and name != cur:
            print(f"error: space '{name}' is not the current space (current is '{cur}')", file=sys.stderr); sys.exit(2)
        set_current_space(cfg, None)
        print("cleared current space")

    elif args.action == "set":
        cur = get_current_space(cfg)
        if not cur:
            print("error: no current space. Use 'clipex space start NAME' first.", file=sys.stderr); sys.exit(2)
        sp = spaces.setdefault(cur, {"in": "", "out": ""})
        changed = False
        if args.in_dir:
            sp["in"] = str(Path(args.in_dir).expanduser())
            changed = True
        if args.out_dir:
            sp["out"] = str(Path(args.out_dir).expanduser())
            changed = True
        if changed:
            save_config(cfg)
            print(f"updated space '{cur}': in={sp.get('in') or '(unset)'} out={sp.get('out') or '(unset)'}")
        if args.list_io or not changed:
            print(f"space '{cur}' I/O:")
            print(f"  in : {sp.get('in') or '(unset)'}")
            print(f"  out: {sp.get('out') or '(unset)'}")

    elif args.action == "list":
        cur = get_current_space(cfg)
        if not spaces:
            print("(no spaces)")
            return
        for name, meta in spaces.items():
            star = "*" if name == cur else " "
            print(f"{star} {name}")
            if VERBOSE:
                print(f"    in : {meta.get('in') or '(unset)'}")
                print(f"    out: {meta.get('out') or '(unset)'}")

    elif args.action == "delete":
        name = args.name
        if not name:
            print("error: space delete requires a NAME", file=sys.stderr); sys.exit(2)
        if name not in spaces:
            print(f"error: space '{name}' not found", file=sys.stderr); sys.exit(2)
        if get_current_space(cfg) == name:
            set_current_space(cfg, None)
        spaces.pop(name, None)
        save_config(cfg)
        print(f"deleted space '{name}'")

    else:
        print("error: unknown space action", file=sys.stderr); sys.exit(2)

# ---------- CLI ----------

def make_parser() -> argparse.ArgumentParser:
    p = argparse.ArgumentParser(
        prog=APP_NAME,
        description=APP_DESC,
        formatter_class=_SmartFormatter,
        epilog=_dedent("""\
            Tips:
              • Times accept M:SS(.ms), H:MM:SS(.ms), or raw seconds(.ms).
              • Use --copy for speed when you don't need fades/filters/mono/CBR.
              • CSV '#default, text...' sets a default description for empty/#default rows.
              • With --concat, prefer --xfade for smooth transitions or --gap for separation.
              • You can pass multiple -i/--input, and/or use a per-row 'source' in CSV.
              • Or skip cutting entirely with --parts to merge existing clips.
              • Use 'clipex space' to organize input/output defaults per project.
            """),
        add_help=False  # we'll add -h/--help manually to include in all subparsers too
    )

    # Global flags
    p.add_argument("-h","--help", action="help", help="Show this help message and exit")
    p.add_argument("--version", action="version", version=f"%(prog)s {APP_VER}", help="Show version and exit")
    p.add_argument("--examples", action="store_true", help="Print practical usage recipes and exit")
    p.add_argument("-y","--yes", action="store_true", help="Overwrite output files without asking (passes -y to ffmpeg)")
    p.add_argument("-v","--verbose", action="store_true", help="Verbose output (show ffmpeg commands, list space I/O)")

    sub = p.add_subparsers(dest="cmd", metavar="COMMAND", title="Commands")

    # ---- run ----
    pr = sub.add_parser(
        "run", help="Run clipex (default)", formatter_class=_SmartFormatter, add_help=False,
        description=_dedent("""\
            Run clipex to cut clips from MP3s.
            Modes:
              • Single clip:   --start + --end (outputs one file, requires exactly one -i)
              • Batch:         -f/--file CSV (outputs many files)
              • Concat:        --concat on a batch (one highlight reel)
              • Parts concat:  --parts (skip cutting; just merge existing clips)
            """)
    )
    pr.add_argument("-h","--help", action="help", help="Show help for 'run' and exit")
    pr.add_argument("--examples", action="store_true", help="Show 'run' examples and exit")

    # IO
    pr.add_argument("-i","--input", metavar="FILE", action="append",
                    help="Input MP3 file. Can be given multiple times; rows without a 'source' column use the first. Resolved against current space's 'in' if set.")
    pr.add_argument("-o","--output", metavar="DIR", help="Output directory (falls back to current space's 'out', then global default)")

    pr.add_argument("--name", metavar="NAME", help="Output file name (single clip) or merged name with --concat")
    pr.add_argument("--info", metavar="TEXT", help="Optional description/notes for metadata")
    pr.add_argument("-f","--file", metavar="CSV",
                    help=_dedent("""\
                        Batch CSV with rows: start,end,name,description[,source]
                        Header is optional (auto-detected). Lines starting with '#default' set
                        a default description for rows that use '#default' or empty description.
                        'source' (optional per row) can reference a different input file for that clip
                        and will be resolved against the current space's 'in' if set.
                        Times support milliseconds: M:SS(.ms), H:MM:SS(.ms), or seconds(.ms)
                    """))
    pr.add_argument("--parts", nargs="+", metavar="MP3",
                    help="Existing clip files to concat (skip cutting). Incompatible with --start/--end and -f/--file.")

    # Single-clip selection
    pr.add_argument("--start", metavar="TIME", help="Start time (M:SS(.ms), H:MM:SS(.ms), or seconds(.ms))")
    pr.add_argument("--end",   metavar="TIME", help="End time (M:SS(.ms), H:MM:SS(.ms), or seconds(.ms))")

    # Performance/accuracy
    pr.add_argument("--copy", action="store_true",
                    help="Try stream copy (fast, less accurate; disabled if filters/mono/CBR are used)")

    # Concat controls
    pr.add_argument("--concat", action="store_true", help="Concatenate all batch clips into one MP3")
    pr.add_argument("--keep-clips", action="store_true", help="With --concat, keep the intermediate cut parts")

    # Audio shaping
    pr.add_argument("--xfade", type=float, default=1.0,
                    help="Crossfade seconds between clips (with --concat). Set 0 to disable.")
    pr.add_argument("--xfade-shape", choices=["tri","log","exp","qsin"], default="tri",
                    help="Crossfade curve shape")
    pr.add_argument("--gap", type=float, default=0.0,
                    help="Silence (seconds) inserted between clips when not using --xfade")
    pr.add_argument("--edge-fade", type=float, default=0.02,
                    help="Tiny fade at start/end of each cut part to prevent clicks")
    pr.add_argument("--loudnorm", type=float, default=None,
                    help="Target LUFS for final loudness (e.g., -16 for podcasts). Re-encodes final.")
    pr.add_argument("--mono", action="store_true", help="Downmix the final output to mono")
    pr.add_argument("--cbr", type=str, default=None, metavar="RATE",
                    help="Force constant bitrate for encoding (e.g., 192k). Default is VBR -q:a 2.")

    # UX niceties
    pr.add_argument("--play", action="store_true", help="Play the resulting clip/output after writing it")

    pr.set_defaults(func=cmd_run)

    # ---- set ----
    ps = sub.add_parser(
        "set", help="Set global defaults", formatter_class=_SmartFormatter, add_help=False,
        description=f"Configure persistent defaults (stored under {CONFIG_PATH})."
    )
    ps.add_argument("-h","--help", action="help", help="Show help for 'set' and exit")
    ps.add_argument("--output-default", metavar="DIR", help="Default output directory for all runs (used when space 'out' and --output are not set)")
    ps.set_defaults(func=cmd_set)

    # ---- space ----
    pspace = sub.add_parser(
        "space", help="Manage named spaces (namespaces) for I/O presets", add_help=False, formatter_class=_SmartFormatter,
        description=_dedent("""\
            Work with project 'spaces' (namespaces) that remember input/output directories.
            Actions:
              • create NAME        Create a space
              • start NAME         Make space current (also: 'change')
              • end [NAME]         Clear current space (NAME must match if provided)
              • set [--in DIR] [--out DIR] [--list-io]   Update/list current space I/O
              • list               List spaces (current one is marked with *)
              • delete NAME        Remove a space
        """)
    )
    pspace.add_argument("-h","--help", action="help", help="Show help for 'space' and exit")
    space_sub = pspace.add_subparsers(dest="action", metavar="ACTION")

    sp_create = space_sub.add_parser("create", help="Create a space", add_help=False)
    sp_create.add_argument("name", help="Space name")
    sp_create.set_defaults(func=cmd_space)

    sp_start = space_sub.add_parser("start", help="Start/use a space", add_help=False)
    sp_start.add_argument("name", help="Space name")
    sp_start.set_defaults(func=cmd_space)

    sp_change = space_sub.add_parser("change", help="Alias of start", add_help=False)
    sp_change.add_argument("name", help="Space name")
    sp_change.set_defaults(func=cmd_space)

    sp_end = space_sub.add_parser("end", help="Clear current space", add_help=False)
    sp_end.add_argument("name", nargs="?", help="(optional) Must match current space if provided")
    sp_end.set_defaults(func=cmd_space)

    sp_set = space_sub.add_parser("set", help="Set I/O for current space", add_help=False)
    sp_set.add_argument("--in", dest="in_dir", metavar="DIR", help="Default input base directory for current space")
    sp_set.add_argument("--out", dest="out_dir", metavar="DIR", help="Default output directory for current space")
    sp_set.add_argument("--list-io", action="store_true", help="List current space I/O")
    sp_set.set_defaults(func=cmd_space)

    sp_list = space_sub.add_parser("list", help="List spaces", add_help=False)
    sp_list.set_defaults(func=cmd_space)

    sp_delete = space_sub.add_parser("delete", help="Delete a space", add_help=False)
    sp_delete.add_argument("name", help="Space name")
    sp_delete.set_defaults(func=cmd_space)

    # ---- help (topic-aware) ----
    ph = sub.add_parser(
        "help", help="Show top-level help or topic help (run | set | space)",
        formatter_class=_SmartFormatter, add_help=False
    )
    ph.add_argument("-h","--help", action="help", help="Show help for 'help' and exit")
    ph.add_argument("topic", nargs="?", help="Help topic: run | set | space")
    ph.set_defaults(func=lambda a: print_topic_help_and_exit(p, a.topic))

    return p

def main(argv=None):
    global VERBOSE, OVERWRITE
    argv = sys.argv[1:] if argv is None else argv
    parser = make_parser()

    # Global --examples works from anywhere (before we potentially dispatch to subcommands)
    if "--examples" in argv and (len(argv) == 1 or argv[0] != "help"):
        print_examples_and_exit()

    # Convenience: if first token isn't a subcommand, treat as 'run'
    if argv and argv[0] not in {"run","set","help","space"}:
        argv = ["run"] + argv

    args = parser.parse_args(argv)

    # set globals
    VERBOSE = bool(getattr(args, "verbose", False))
    OVERWRITE = bool(getattr(args, "yes", False))

    # 'help' subcommand already exits; others continue
    if not hasattr(args, "func"):
        parser.print_help()
        return 2
    try:
        return args.func(args) or 0
    except (ValueError, RuntimeError) as e:
        print(f"error: {e}", file=sys.stderr)
        return 1

if __name__ == "__main__":
    sys.exit(main())

