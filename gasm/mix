#!/usr/bin/env python3
"""
Mix CLI with Spaces, Wizard, TUI, and Learn system
"""

from __future__ import annotations
import argparse, subprocess, sys, shutil, yaml
from pathlib import Path
from dataclasses import dataclass, asdict, field
from typing import List, Dict, Optional, Any

# ------------------------
# Track spec + parser
# ------------------------
@dataclass
class TrackSpec:
    file: str
    vol: float = 0.0
    speed: float = 1.0
    echo: Optional[str] = None
    offset: float = 0.0
    fade_in: float = 0.0
    fade_out: float = 0.0
    pan: Optional[str] = None
    loop: bool = False

@dataclass
class MixConfig:
    main: str
    output: str
    tracks: List[TrackSpec] = field(default_factory=list)
    main_vol: float = 0.0
    main_speed: float = 1.0
    fade_in: float = 0.0
    fade_out: float = 0.0
    duck: Optional[float] = None
    normalize: bool = False
    limit_dbfs: Optional[float] = None
    bitrate: str = "192k"
    out_codec: str = "libmp3lame"

# ------------------------
# Spaces manager
# ------------------------
APP_DIR = Path.home() / "apps/.app-data/mix/data"
SPACES_FILE = APP_DIR / "spaces.yml"
DEFAULT_SPACE = "home"

def load_spaces() -> Dict[str, Any]:
    if not SPACES_FILE.exists():
        return {"current": DEFAULT_SPACE, "spaces": {
            DEFAULT_SPACE: {"in_dir": str(APP_DIR/"spaces"/DEFAULT_SPACE/"in"),
                            "out_dir": str(APP_DIR/"spaces"/DEFAULT_SPACE/"out"),
                            "active": True}}}
    return yaml.safe_load(SPACES_FILE.read_text()) or {}

def save_spaces(data: Dict[str, Any]):
    SPACES_FILE.parent.mkdir(parents=True, exist_ok=True)
    SPACES_FILE.write_text(yaml.safe_dump(data))

SP = load_spaces()

def space_current() -> str: return SP.get("current", DEFAULT_SPACE)
def space_dirs() -> Dict[str,str]: return SP["spaces"][space_current()]

# ------------------------
# ffmpeg helpers
# ------------------------
def check_ffmpeg():
    if shutil.which("ffmpeg") is None:
        sys.exit("ffmpeg not found")

def run_cmd(cmd: List[str]) -> int:
    print(" ".join(cmd))
    return subprocess.run(cmd).returncode

def atempo_chain(tempo: float) -> str:
    stages, t = [], tempo
    while t < 0.5: stages.append(0.5); t/=0.5
    while t > 2.0: stages.append(2.0); t/=2.0
    stages.append(t)
    return ",".join(f"atempo={x:.6g}" for x in stages)

def make_ffmpeg(config: MixConfig) -> List[str]:
    cmd = ["ffmpeg", "-y", "-i", config.main]
    for t in config.tracks:
        if t.loop: cmd += ["-stream_loop","-1"]
        cmd += ["-i", t.file]
    inputs = 1+len(config.tracks)
    fgraph = f"amix=inputs={inputs}:normalize={'1' if config.normalize else '0'}[mix]"
    return cmd + ["-filter_complex", fgraph, "-map","[mix]","-c:a",config.out_codec,"-b:a",config.bitrate,config.output]

# ------------------------
# Wizard
# ------------------------
def run_wizard():
    dirs = space_dirs()
    in_dir, out_dir = Path(dirs["in_dir"]), Path(dirs["out_dir"])
    in_dir.mkdir(parents=True, exist_ok=True)
    out_dir.mkdir(parents=True, exist_ok=True)
    main = input("Main track file: ").strip()
    output = str(out_dir/"mix_out.mp3")
    tracks=[]
    while input("Add bg track? (y/N): ").lower()=="y":
        fn=input(" file: ").strip()
        vol=float(input(" vol dB (0): ") or 0)
        tracks.append(TrackSpec(file=fn,vol=vol))
    cfg = MixConfig(main=main,output=output,tracks=tracks)
    fname=in_dir/"session.mix.yml"
    fname.write_text(yaml.safe_dump(asdict(cfg)))
    print(f"âœ“ Saved config {fname}")
    if input("Render now? (y/N): ").lower()=="y":
        return run_cmd(make_ffmpeg(cfg))
    return 0

# ------------------------
# Build
# ------------------------
def run_build(cfgfile: Path):
    cfg=MixConfig(**yaml.safe_load(cfgfile.read_text()))
    return run_cmd(make_ffmpeg(cfg))

# ------------------------
# Monitor
# ------------------------
def run_monitor(cfgfile: Path):
    cfg=MixConfig(**yaml.safe_load(cfgfile.read_text()))
    cmd=make_ffmpeg(cfg)
    cmd[-1]="-" # output to stdout
    ffplay=["ffplay","-autoexit","-nodisp","-"]
    p1=subprocess.Popen(cmd,stdout=subprocess.PIPE)
    p2=subprocess.Popen(ffplay,stdin=p1.stdout)
    p1.stdout.close();p2.communicate();return 0

# ------------------------
# Learn
# ------------------------
LEARN_TOPICS={
 "intro":"Mix audio with ffmpeg easily using configs and spaces.",
 "spaces":"Workspaces keep scripts and outputs isolated.",
 "wizard":"Guided workflow to build configs.",
 "tui":"Interactive table editor (tracks inline).",
 "build":"Render from config file.",
 "monitor":"Preview mix with ffplay.",
 "cheatsheet":"mix wizard | mix tui | mix build config.yml | mix monitor config.yml"
}

def run_learn(topic: Optional[str]):
    if not topic:
        print("Topics:"," ".join(LEARN_TOPICS.keys()));return 0
    print(LEARN_TOPICS.get(topic,"Unknown topic"));return 0

# ------------------------
# TUI
# ------------------------
def run_tui(cfgfile: Optional[Path]=None):
    try:
        from textual.app import App, ComposeResult
        from textual.widgets import DataTable, Footer, Header, Button
    except ImportError:
        sys.exit("textual required for tui")

    class MixTUI(App):
        CSS="Screen{layout:vertical;} #tbl{height:1fr;}"
        def __init__(self,cfgpath:Optional[Path]): super().__init__(); self.cfgpath=cfgpath; self.cfg=None
        def compose(self)->ComposeResult:
            yield Header(); self.tbl=DataTable(id="tbl"); yield self.tbl
            yield Button("Save",id="save"); yield Button("Render",id="render"); yield Footer()
        def on_mount(self):
            self.tbl.add_columns("file","vol","speed","offset","fade_in","fade_out","pan","loop")
            if self.cfgpath and self.cfgpath.exists():
                self.cfg=MixConfig(**yaml.safe_load(self.cfgpath.read_text()))
                for t in self.cfg.tracks:
                    self.tbl.add_row(t.file,str(t.vol),str(t.speed),str(t.offset),str(t.fade_in),str(t.fade_out),str(t.pan or ""),str(int(t.loop)))
        def on_button_pressed(self,e):
            if e.button.id=="save":
                rows=[TrackSpec(file=r[0],vol=float(r[1]),speed=float(r[2]),offset=float(r[3]),
                        fade_in=float(r[4]),fade_out=float(r[5]),pan=(r[6] or None),loop=(r[7]=="1"))
                      for r in self.tbl.rows.values()]
                cfg=MixConfig(main=self.cfg.main if self.cfg else "main.mp3",
                              output=self.cfg.output if self.cfg else "out.mp3",
                              tracks=rows)
                self.cfgpath.write_text(yaml.safe_dump(asdict(cfg)))
                self.notify("Saved config")
            if e.button.id=="render":
                run_cmd(make_ffmpeg(self.cfg))

    cfg=cfgfile or Path(space_dirs()["in_dir"])/"session.mix.yml"
    MixTUI(cfg).run();return 0

# ------------------------
# CLI
# ------------------------
def main(argv=None):
    p=argparse.ArgumentParser("mix",description="Mix CLI with spaces")
    sub=p.add_subparsers(dest="cmd",required=True)
    sub.add_parser("wizard")
    b=sub.add_parser("build");b.add_argument("config",type=Path)
    m=sub.add_parser("monitor");m.add_argument("config",type=Path)
    t=sub.add_parser("tui");t.add_argument("config",type=Path,nargs="?")
    l=sub.add_parser("learn");l.add_argument("topic",nargs="?")
    sp=sub.add_parser("space");sp.add_argument("action",choices=["list","create","set","change","start","stop","status"])
    sp.add_argument("name",nargs="?");sp.add_argument("--indir");sp.add_argument("--outdir")

    args=p.parse_args(argv)

    if args.cmd=="wizard": return run_wizard()
    if args.cmd=="build": return run_build(args.config)
    if args.cmd=="monitor": return run_monitor(args.config)
    if args.cmd=="tui": return run_tui(args.config)
    if args.cmd=="learn": return run_learn(args.topic)
    if args.cmd=="space":
        if args.action=="list": print("\n".join(SP["spaces"].keys()))
        elif args.action=="create":
            nm=args.name; root=APP_DIR/"spaces"/nm
            SP["spaces"][nm]={"in_dir":str(root/"in"),"out_dir":str(root/"out"),"active":False}; save_spaces(SP); print(f"created {nm}")
        elif args.action=="set":
            cur=space_current(); s=SP["spaces"][cur]
            if args.indir: s["in_dir"]=args.indir
            if args.outdir: s["out_dir"]=args.outdir
            save_spaces(SP); print("set paths")
        elif args.action=="change": SP["current"]=args.name; save_spaces(SP)
        elif args.action=="start": SP["spaces"][args.name]["active"]=True; save_spaces(SP)
        elif args.action=="stop": SP["spaces"][args.name]["active"]=False; save_spaces(SP)
        elif args.action=="status":
            print("\nCurrent:",space_current(), "\n")
    return 0

if __name__=="__main__":
    sys.exit(main())

