#!/usr/bin/env python3
"""
clip â€” cut podcast/audio clips; batch, concat, crossfade, fades, and waveforms.

Features:
- Times with millisecond precision (e.g., 1.1, 0:01.200, 1:02:03.456).
- Single cut, batch CSV, concat, and crossfade.
- Optional per-clip fade-in/out (single or batch).
- Optional waveform/spectrogram PNG outputs (single or merged).
- Robust ffmpeg binary resolution (env/config/PATH) with clear errors.

Notes:
- Requires the ffmpeg executable. Install via your OS package manager (apt/pacman/dnf/zypper/brew/choco).
- 'pip install ffmpeg' does NOT install the ffmpeg binary.
- Set a custom binary with:
    clip set --ffmpeg-bin /path/to/ffmpeg
  or:
    FFMPEG_BIN=/path/to/ffmpeg clip run ...
"""
import argparse, csv, json, os, re, subprocess, sys, tempfile, shutil
from pathlib import Path
from typing import Optional, Tuple, List

APP_NAME = "clip"
BATCH_DIR = Path.home() / "media/audio/batch-files"
CONFIG_DIR = Path(os.environ.get("XDG_CONFIG_HOME", Path.home() / "apps/.app-data/.config-files")) / APP_NAME
CONFIG_PATH = CONFIG_DIR / "config.json"

# Support mm:ss(.ms), hh:mm:ss(.ms), or raw seconds(.ms)
TIME_PATTERNS = [
    re.compile(r"^(?P<m>\d+):(?P<s>[0-5]?\d(?:\.\d+)?)$"),                 # M:SS(.ms)
    re.compile(r"^(?P<h>\d+):(?P<m>[0-5]?\d):(?P<s>[0-5]?\d(?:\.\d+)?)$"), # H:MM:SS(.ms)
    re.compile(r"^(?P<s>\d+(?:\.\d+)?)$"),                                 # seconds(.ms)
]

def parse_time(ts: str) -> float:
    s = ts.strip()
    for pat in TIME_PATTERNS:
        m = pat.match(s)
        if m:
            h = float(m.groupdict().get("h") or 0)
            m_ = float(m.groupdict().get("m") or 0)
            s_ = float(m.groupdict().get("s") or 0)
            return h * 3600 + m_ * 60 + s_
    raise ValueError(f"Invalid time format: {ts!r}")

def load_config() -> dict:
    if CONFIG_PATH.exists():
        try:
            return json.loads(CONFIG_PATH.read_text())
        except Exception:
            pass
    return {}

def save_config(cfg: dict) -> None:
    CONFIG_DIR.mkdir(parents=True, exist_ok=True)
    CONFIG_PATH.write_text(json.dumps(cfg, indent=2))

def find_ffmpeg(cfg: dict) -> str:
    """
    Resolve an ffmpeg binary path in this priority:
      1) env FFMPEG_BIN
      2) config["ffmpeg_bin"]
      3) PATH: ffmpeg
      4) PATH: avconv (fallback)
    """
    cand = os.environ.get("FFMPEG_BIN") or cfg.get("ffmpeg_bin")
    if cand and shutil.which(cand):
        return shutil.which(cand)  # normalized absolute path
    for name in ("ffmpeg", "avconv"):
        p = shutil.which(name)
        if p:
            return p
    raise FileNotFoundError(
        "ffmpeg binary not found. Install it with your package manager "
        "(e.g. apt/pacman/dnf/zypper/brew/choco). "
        "Note: 'pip install ffmpeg' does NOT install the ffmpeg executable."
    )

def ensure_outdir(path: Optional[str], cfg: dict) -> Path:
    outdir = Path(path) if path else Path(cfg.get("output_default", "."))
    outdir.mkdir(parents=True, exist_ok=True)
    return outdir

def sanitize_filename(name: str) -> str:
    return re.sub(r'[\\/:*?"<>|]+', "_", name).strip()

def run_ffmpeg_cut(ffbin: str, input_mp3: Path, start_s: float, end_s: float, out_path: Path,
                   title: Optional[str] = None, comment: Optional[str] = None,
                   copy: bool = False, fade_in: float = 0.0, fade_out: float = 0.0) -> None:
    if end_s <= start_s:
        raise ValueError("end must be greater than start")
    dur = end_s - start_s
    meta = []
    if title:
        meta += ["-metadata", f"title={title}"]
    if comment:
        meta += ["-metadata", f"comment={comment}"]

    # If fades requested, we must re-encode and apply 'afade'
    if fade_in > 0 or fade_out > 0 or not copy:
        afilters = []
        if fade_in > 0:
            afilters.append(f"afade=t=in:st=0:d={fade_in}")
        if fade_out > 0:
            afilters.append(f"afade=t=out:st={max(0.0, dur - fade_out)}:d={fade_out}")
        filter_arg = ["-af", ",".join(afilters)] if afilters else []
        cmd = [
            ffbin, "-hide_banner", "-loglevel", "error", "-y",
            "-ss", f"{start_s:.3f}", "-t", f"{dur:.3f}",
            "-i", str(input_mp3),
            *filter_arg,
            "-acodec", "libmp3lame", "-q:a", "2",
            *meta, str(out_path)
        ]
    else:
        # stream copy (no fades possible)
        cmd = [
            ffbin, "-hide_banner", "-loglevel", "error", "-y",
            "-ss", f"{start_s:.3f}", "-t", f"{dur:.3f}",
            "-i", str(input_mp3),
            "-c", "copy",
            *meta, str(out_path)
        ]

    if subprocess.run(cmd).returncode != 0:
        raise RuntimeError(f"ffmpeg failed for {out_path.name}")

def sniff_has_header(row: List[str]) -> bool:
    joined = ",".join(c.strip().lower() for c in row)
    # accept any of these 'start'/'end' cues in header
    return "start" in joined and "end" in joined

def parse_batch_file(path: Path) -> Tuple[str, List[dict]]:
    """
    CSV format:
      #default, Your default description (optional; first such line wins)
      start,end,name,description,fade_in,fade_out
      3:55,4:55,hot_take,#default,0.10,0.10
      2:35,3:33,funny_bit,Hosts crack up,0.15,0.20
      420,505,,,
    """
    default_desc = ""
    clips: List[dict] = []
    with path.open(newline="", encoding="utf-8") as f:
        reader = csv.reader(f)
        first_row = None
        for raw in reader:
            if not raw or (len(raw) == 1 and not raw[0].strip()):
                continue
            if raw[0].strip().startswith("#default"):
                if len(raw) >= 2:
                    default_desc = ",".join(raw[1:]).strip()
                continue
            if raw[0].strip().startswith("#"):
                continue
            if first_row is None:
                first_row = raw
                if sniff_has_header(first_row):
                    first_row = None
                    continue
            row = raw if first_row is None else first_row
            first_row = None
            # allow up to 6 fields; pad missing
            row = (row + ["", "", "", "", "", ""])[:6]
            start, end, name, desc, fade_in_s, fade_out_s = [c.strip() for c in row]
            if not start or not end:
                raise ValueError(f"Batch row missing start/end: {row}")
            start_s = parse_time(start)
            end_s = parse_time(end)
            nm = sanitize_filename(name) if name else ""
            description = default_desc if (desc == "#default" or desc == "") else desc
            fade_in = float(fade_in_s) if fade_in_s else 0.0
            fade_out = float(fade_out_s) if fade_out_s else 0.0
            clips.append({
                "start_s": start_s, "end_s": end_s, "name": nm,
                "description": description,
                "fade_in": fade_in, "fade_out": fade_out
            })
    return default_desc, clips

def derive_outfile(base_dir: Path, base_name: Optional[str], idx: int) -> Path:
    stem = sanitize_filename(base_name) if base_name else f"clip_{idx:02d}"
    return base_dir / f"{stem}.mp3"

def ffmpeg_concat_list(ffbin: str, list_file: Path, out_path: Path, copy: bool,
                       title: Optional[str], comment: Optional[str]) -> None:
    codec_args = ["-c", "copy"] if copy else ["-acodec", "libmp3lame", "-q:a", "2"]
    meta = []
    if title:
        meta += ["-metadata", f"title={title}"]
    if comment:
        meta += ["-metadata", f"comment={comment}"]
    cmd = [ffbin, "-hide_banner", "-loglevel", "error", "-y", "-f", "concat", "-safe", "0",
           "-i", str(list_file), *codec_args, *meta, str(out_path)]
    if subprocess.run(cmd).returncode != 0:
        raise RuntimeError(f"ffmpeg concat failed for {out_path.name}")

def ffmpeg_concat_xfade(ffbin: str, parts: List[Path], out_path: Path, xfade: float,
                        title: Optional[str], comment: Optional[str]) -> None:
    """
    Build an acrossfade chain over N inputs:
      [0:a][1:a]acrossfade=d=XF:... [af1];
      [af1][2:a]acrossfade=d=XF:... [af2];
      ...
      map last [afX]
    """
    if len(parts) == 1:
        cmd = [ffbin, "-hide_banner", "-loglevel", "error", "-y",
               "-i", str(parts[0]), "-acodec", "libmp3lame", "-q:a", "2"]
        if title:
            cmd += ["-metadata", f"title={title}"]
        if comment:
            cmd += ["-metadata", f"comment={comment}"]
        cmd += [str(out_path)]
        if subprocess.run(cmd).returncode != 0:
            raise RuntimeError(f"ffmpeg failed for {out_path.name}")
        return

    cmd = [ffbin, "-hide_banner", "-loglevel", "error", "-y"]
    for p in parts:
        cmd += ["-i", str(p)]

    filters = []
    prev = "0:a"
    for i in range(1, len(parts)):
        cur = f"{i}:a"
        out = f"af{i}"
        # triangular shape is a nice neutral default
        filters.append(f"[{prev}][{cur}]acrossfade=d={xfade}:c1=tri:c2=tri[{out}]")
        prev = out
    filter_complex = ";".join(filters)

    out_args = ["-map", f"[{prev}]", "-acodec", "libmp3lame", "-q:a", "2"]
    if title:
        out_args += ["-metadata", f"title={title}"]
    if comment:
        out_args += ["-metadata", f"comment={comment}"]

    cmd += ["-filter_complex", filter_complex, *out_args, str(out_path)]
    if subprocess.run(cmd).returncode != 0:
        raise RuntimeError(f"ffmpeg xfade failed for {out_path.name}")

def render_wave_image(ffbin: str, audio_path: Path, width: int, height: int, png_out: Path, spectro: bool=False) -> None:
    if spectro:
        filt = f"showspectrumpic=s={width}x{height}:legend=disabled"
    else:
        filt = f"showwavespic=s={width}x{height}:split_channels=0"
    cmd = [ffbin, "-hide_banner", "-loglevel", "error", "-y",
           "-i", str(audio_path),
           "-filter_complex", filt,
           "-frames:v", "1", str(png_out)]
    if subprocess.run(cmd).returncode != 0:
        raise RuntimeError(f"waveform render failed for {audio_path.name}")

def cmd_set(args):
    cfg = load_config()
    if args.output_default:
        cfg["output_default"] = str(Path(args.output_default).expanduser())
        save_config(cfg)
        print(f"Set output default to: {cfg['output_default']}")
    if getattr(args, "ffmpeg_bin", None):
        cfg["ffmpeg_bin"] = args.ffmpeg_bin
        save_config(cfg)
        print(f"Set ffmpeg binary to: {cfg['ffmpeg_bin']}")

def cmd_run(args):
    cfg = load_config()
    # Resolve ffmpeg early so we fail fast with a helpful error
    try:
        ffbin = find_ffmpeg(cfg)
    except FileNotFoundError as e:
        print(f"error: {e}", file=sys.stderr); sys.exit(127)

    if not args.input:
        print("error: -i/--input is required", file=sys.stderr); sys.exit(2)
    input_mp3 = Path(args.input).expanduser()
    if not input_mp3.exists():
        print(f"error: input file not found: {input_mp3}", file=sys.stderr); sys.exit(2)
    outdir = ensure_outdir(args.output, cfg)

    # SINGLE CLIP (no concat)
    if args.start and args.end and not args.concat:
        start_s = parse_time(args.start)
        end_s = parse_time(args.end)
        name = sanitize_filename(args.name) if args.name else f"{input_mp3.stem}_{int(start_s)}-{int(end_s)}"
        out_path = outdir / f"{name}.mp3"
        run_ffmpeg_cut(ffbin, input_mp3, start_s, end_s, out_path,
                       title=args.name or name, comment=args.info, copy=args.copy,
                       fade_in=args.fade_in, fade_out=args.fade_out)
        print(f"wrote {out_path}")
        if args.waveform or args.spectrogram:
            png = out_path.with_suffix(".png") if args.waveform else out_path.with_suffix(".spec.png")
            render_wave_image(ffbin, out_path, args.img_width, args.img_height, png, spectro=args.spectrogram)
            print(f"wrote {png}")
        return

    # BATCH
    if args.file:
        batch_path = (BATCH_DIR / args.file).expanduser()

        if not batch_path.exists():
            print(f"error: batch file not found: {batch_path}", file=sys.stderr); sys.exit(2)
        default_desc, clips = parse_batch_file(batch_path)
        if not clips:
            print("no clips found in batch file", file=sys.stderr); sys.exit(2)

        if args.concat:
            merged_name = sanitize_filename(args.name) if args.name else f"{input_mp3.stem}_highlights"
            merged_out = outdir / f"{merged_name}.mp3"
            tmp_dir = Path(tempfile.mkdtemp(prefix="podmix_", dir=str(outdir)))
            parts: List[Path] = []
            try:
                # always cut parts; for xfade we re-encode final output
                for i, c in enumerate(clips, 1):
                    part_path = tmp_dir / f"part_{i:02d}.mp3"
                    run_ffmpeg_cut(
                        ffbin, input_mp3, c["start_s"], c["end_s"], part_path,
                        title=f"{merged_name}_part_{i:02d}",
                        comment=c.get("description") or args.info or default_desc,
                        copy=(args.copy and not args.xfade),
                        fade_in=c.get("fade_in", args.fade_in),
                        fade_out=c.get("fade_out", args.fade_out)
                    )
                    parts.append(part_path)

                if args.xfade and len(parts) >= 2:
                    ffmpeg_concat_xfade(
                        ffbin=ffbin,
                        parts=parts,
                        out_path=merged_out,
                        xfade=args.xfade,
                        title=merged_name,
                        comment=args.info or default_desc
                    )
                else:
                    # plain concat (can stream copy if requested)
                    list_file = tmp_dir / "concat.txt"
                    with list_file.open("w", encoding="utf-8") as lf:
                        for p in parts:
                            lf.write(f"file '{p.as_posix()}'\n")
                    ffmpeg_concat_list(
                        ffbin=ffbin,
                        list_file=list_file, out_path=merged_out, copy=args.copy,
                        title=merged_name, comment=args.info or default_desc
                    )

                print(f"wrote {merged_out}")

                if args.waveform or args.spectrogram:
                    png = merged_out.with_suffix(".png") if args.waveform else merged_out.with_suffix(".spec.png")
                    render_wave_image(ffbin, merged_out, args.img_width, args.img_height, png, spectro=args.spectrogram)
                    print(f"wrote {png}")

                if args.keep_clips:
                    clips_dir = outdir / f"{merged_name}_parts"
                    clips_dir.mkdir(exist_ok=True)
                    for p in parts:
                        p.replace(clips_dir / p.name)
                    print(f"kept parts in {clips_dir}")
            finally:
                if not args.keep_clips:
                    for p in tmp_dir.glob("*"):
                        try:
                            p.unlink()
                        except:
                            pass
                    try:
                        tmp_dir.rmdir()
                    except:
                        pass
            return

        # normal batch (no concat)
        for i, c in enumerate(clips, 1):
            out_path = derive_outfile(outdir, c.get("name"), i)
            run_ffmpeg_cut(
                ffbin, input_mp3, c["start_s"], c["end_s"], out_path,
                title=out_path.stem,
                comment=c.get("description") or args.info or default_desc,
                copy=args.copy,
                fade_in=c.get("fade_in", args.fade_in),
                fade_out=c.get("fade_out", args.fade_out)
            )
            print(f"wrote {out_path}")
            if args.waveform_each or args.spectrogram_each:
                png = out_path.with_suffix(".png") if args.waveform_each else out_path.with_suffix(".spec.png")
                render_wave_image(ffbin, out_path, args.img_width, args.img_height, png, spectro=args.spectrogram_each)
                print(f"wrote {png}")
        return

    print("error: provide --start and --end for a single clip, or -f/--file for batch mode.", file=sys.stderr)
    sys.exit(2)

def make_parser():
    p = argparse.ArgumentParser(prog=APP_NAME, description="Cut podcast clips from MP3s; batch, concat, crossfade, fades, and waveforms.")
    sub = p.add_subparsers(dest="cmd")

    pr = sub.add_parser("run", help="Run clip")
    pr.add_argument("-i","--input", help="Input MP3 file")
    pr.add_argument("--start", help="Start time (M:SS, H:MM:SS, or seconds; supports .ms)")
    pr.add_argument("--end", help="End time (M:SS, H:MM:SS, or seconds; supports .ms)")
    pr.add_argument("-o","--output", help="Output directory")
    pr.add_argument("--name", help="Output filename (single clip) or merged name with --concat")
    pr.add_argument("--info", help="Optional description/notes for metadata")
    pr.add_argument("-f","--file", help="Batch file (CSV) with rows: start,end,name,description,fade_in,fade_out")
    pr.add_argument("--copy", action="store_true", help="Try stream copy (faster, less accurate; ignored for fades or --xfade)")
    pr.add_argument("--concat", action="store_true", help="Concatenate all batch clips into one MP3")
    pr.add_argument("--keep-clips", action="store_true", help="With --concat, keep the intermediate per-range clips")
    pxf = pr.add_argument_group("crossfade")
    pxf.add_argument("--xfade", type=float, default=0.0, help="Crossfade seconds between clips (with --concat)")

    pfade = pr.add_argument_group("fades")
    pfade.add_argument("--fade-in", type=float, default=0.0, help="Fade-in seconds (single clip or batch default)")
    pfade.add_argument("--fade-out", type=float, default=0.0, help="Fade-out seconds (single clip or batch default)")

    pimg = pr.add_argument_group("images")
    pimg.add_argument("--waveform", action="store_true", help="Write a waveform PNG for the result (single or merged)")
    pimg.add_argument("--spectrogram", action="store_true", help="Write a spectrogram PNG for the result (single or merged)")
    pimg.add_argument("--waveform-each", action="store_true", help="Write waveform PNG for each batch clip (no concat)")
    pimg.add_argument("--spectrogram-each", action="store_true", help="Write spectrogram PNG for each batch clip (no concat)")
    pimg.add_argument("--img-width", type=int, default=1280, help="Waveform/spectrogram width")
    pimg.add_argument("--img-height", type=int, default=250, help="Waveform/spectrogram height")

    pr.set_defaults(func=cmd_run)

    # convenience: root behaves like run
    p.add_argument("-i","--input", help=argparse.SUPPRESS)
    p.add_argument("--start", help=argparse.SUPPRESS)
    p.add_argument("--end", help=argparse.SUPPRESS)
    p.add_argument("-o","--output", help=argparse.SUPPRESS)
    p.add_argument("--name", help=argparse.SUPPRESS)
    p.add_argument("--info", help=argparse.SUPPRESS)
    p.add_argument("-f","--file", help=argparse.SUPPRESS)
    p.add_argument("--copy", action="store_true", help=argparse.SUPPRESS)
    p.add_argument("--concat", action="store_true", help=argparse.SUPPRESS)
    p.add_argument("--keep-clips", action="store_true", help=argparse.SUPPRESS)
    p.add_argument("--xfade", type=float, default=0.0, help=argparse.SUPPRESS)
    p.add_argument("--fade-in", type=float, default=0.0, help=argparse.SUPPRESS)
    p.add_argument("--fade-out", type=float, default=0.0, help=argparse.SUPPRESS)
    p.add_argument("--waveform", action="store_true", help=argparse.SUPPRESS)
    p.add_argument("--spectrogram", action="store_true", help=argparse.SUPPRESS)
    p.add_argument("--waveform-each", action="store_true", help=argparse.SUPPRESS)
    p.add_argument("--spectrogram-each", action="store_true", help=argparse.SUPPRESS)
    p.add_argument("--img-width", type=int, default=1280, help=argparse.SUPPRESS)
    p.add_argument("--img-height", type=int, default=250, help=argparse.SUPPRESS)

    ps = sub.add_parser("set", help="Set defaults")
    ps.add_argument("--output-default", help="Default output directory")
    ps.add_argument("--ffmpeg-bin", help="Path to ffmpeg binary (else env FFMPEG_BIN or PATH)")
    ps.set_defaults(func=cmd_set)
    return p

def main(argv=None):
    argv = sys.argv[1:] if argv is None else argv
    parser = make_parser()
    if argv and argv[0] not in {"run","set"}:
        argv = ["run"] + argv
    args = parser.parse_args(argv)
    if not hasattr(args, "func"):
        parser.print_help()
        return 2
    try:
        return args.func(args) or 0
    except (ValueError, RuntimeError) as e:
        print(f"error: {e}", file=sys.stderr)
        return 1
    except FileNotFoundError as e:
        print(f"error: {e}", file=sys.stderr)
        return 127

if __name__ == "__main__":
    sys.exit(main())

